<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Quiet Tea Shop</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            background-color: #1a1a1a;
        }
        #canvas-container {
            width: 100%; 
            height: 100%;
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #eee;
            text-shadow: 2px 2px 0px #000;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background-color: #fff;
            border: 2px solid #000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #interaction-prompt {
            position: absolute;
            top: 58%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffcc00;
            opacity: 0;
            transition: opacity 0.1s;
            background: rgba(0,0,0,0.8);
            padding: 8px 15px;
            border: 2px solid #fff;
            transform: skew(-10deg) translateX(-50%);
        }
        #message-log {
            position: absolute;
            bottom: 30px;
            left: 30px;
            font-size: 1.2rem;
            color: #fff;
            font-weight: bold;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-left: 5px solid #ffcc00;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #current-order-card {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 250px;
            background: #fff;
            color: #000;
            padding: 15px;
            border: 3px solid #000;
            font-family: 'Courier New', Courier, monospace;
            display: none; /* Hidden until book picked up */
            transform: rotate(-2deg);
            box-shadow: 5px 5px 0px rgba(0,0,0,0.5);
        }
        #task-list {
            position: absolute;
            top: 30px;
            left: 30px;
            width: 250px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 15px;
            border: 2px solid #fff;
            font-family: 'Courier New', Courier, monospace;
            text-align: left;
            box-shadow: 3px 3px 0px #000;
        }
        #recipe-collection-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            background: #ffcc00;
            color: #000;
            border: 3px solid #fff;
            padding: 10px 20px;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
            font-family: 'Courier New', Courier, monospace;
            box-shadow: 3px 3px 0px #000;
            display: none; /* Hidden until book picked up */
        }
        #recipe-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 400px;
            background: #fff;
            color: #000;
            border: 5px solid #000;
            padding: 30px;
            display: none;
            pointer-events: auto;
            box-shadow: 10px 10px 0px rgba(0,0,0,0.5);
            font-family: 'Courier New', Courier, monospace;
            overflow-y: auto;
            z-index: 100;
        }
        .recipe-entry {
            border-bottom: 1px dashed #000;
            padding: 10px 0;
            display: flex;
            justify-content: space-between;
        }
        .recipe-name { font-weight: bold; font-size: 1.2em; }
        .recipe-ingredients { font-style: italic; color: #555; }
        .locked { color: #aaa; }
        
        .task-header { font-size: 1.2em; font-weight: bold; color: #ffcc00; border-bottom: 1px solid #fff; margin-bottom: 10px; display: block;}
        .task-item { margin: 5px 0; display: flex; align-items: center; }
        .task-checkbox { width: 15px; height: 15px; border: 1px solid #fff; margin-right: 10px; display: inline-block; }
        .task-checked { background-color: #00aa00; }
        
        h1 { 
            font-size: 4rem; 
            margin-bottom: 10px; 
            color: #ffcc00; 
            text-shadow: 4px 4px 0px #000; 
            transform: skew(-5deg); 
        }
        
        #instructions {
            text-align: center;
            color: #eee;
        }

        p { font-size: 1.2rem; margin: 5px; font-weight: bold; }
        
        .key { background: #fff; color: #000; padding: 2px 8px; border: 2px solid #000; font-weight: 900; }
        
        #blocker { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; flex-direction: column; pointer-events: auto; }
        .recipe-title { font-size: 1.2em; font-weight: bold; border-bottom: 2px solid #000; margin-bottom: 10px; display: block;}
        .flash { animation: flashAnim 0.5s ease; }
        @keyframes flashAnim { 0% { background-color: #ff0; } 100% { background-color: #fff; } }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="crosshair"></div>
    <div id="interaction-prompt"></div>
    <div id="message-log"></div>
    
    <div id="task-list">
        <span class="task-header">To-Do List</span>
        <div id="task-1" class="task-item"><span class="task-checkbox"></span>Find Recipe List</div>
        <div id="task-2" class="task-item" style="opacity: 0.5"><span class="task-checkbox"></span>Complete 1st Order</div>
    </div>

    <div id="current-order-card">
        <span class="recipe-title">Current Order</span>
        <div id="recipe-target">Loading...</div>
        <span style="display:block; margin-top:10px; color: #00aa00; font-weight:bold;">Completed: <span id="score-val">0</span></span>
    </div>

    <button id="recipe-collection-btn">Open Recipes [R]</button>

    <div id="recipe-modal">
        <h2 style="text-align:center; border-bottom: 3px solid #000;">Master Recipe Collection</h2>
        <div id="recipe-list-container"></div>
        <div style="text-align:center; margin-top:20px;">
            <button id="close-modal-btn" style="padding:5px 20px; font-weight:bold; background:#000; color:#fff; cursor:pointer;">CLOSE</button>
        </div>
    </div>

    <div id="blocker">
        <div id="instructions">
            <h1>The Quiet Tea Shop</h1>
            <p>-- CEL-SHADED EDITION --</p>
            <br>
            <p>Click to Enter</p>
            <p><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> to Move</p>
            <p><span class="key">SHIFT</span> to Sprint, <span class="key">CTRL</span> to Crouch</p>
            <p><span class="key">SPACE</span> to Jump</p>
            <p><span class="key">E</span> to Pick Up / Place / Mix / Empty</p>
            <p><span class="key">L-CLICK</span> to Use Item (Sip/Pour)</p>
            <p><span class="key">R</span> to View Recipes</p>
        </div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Game Constants ---
        const PLAYER_HEIGHT = 1.7;
        const CROUCH_HEIGHT = 1.0; 
        const WALK_SPEED = 5.0;
        const SPRINT_SPEED = 9.0;
        const JUMP_FORCE = 10.0;
        const GRAVITY = 25.0;
        const INTERACTION_DISTANCE = 4.5;

        // --- Globals ---
        let camera, scene, renderer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isSprinting = false;
        let isCrouching = false; 
        let canJump = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        // Object Tracking
        const environmentGroup = new THREE.Group(); 
        const collidableObjects = []; 
        const interactables = [];     
        let heldItem = null;
        let isAnimatingAction = false; 
        
        // Game Logic
        let hasRecipeBook = false;
        let currentRecipe = null;
        let score = 0;
        let isRecipeModalOpen = false;

        // --- NEW FEATURES GLOBALS ---
        let radioState = 0; // 0: Off, 1: Lo-Fi 1, 2: Lo-Fi 2
        let nextNoteTime = 0;
        const steamParticles = [];
        
        // Updated Recipes with Quantities
        const ALL_RECIPES = [
            { id: 1, name: "Royal Milk Tea", base: "Earl Grey", adds: [{n:"Milk", q:1}, {n:"Sugar", q:2}], unlocked: false },
            { id: 2, name: "Matcha Latte", base: "Matcha", adds: [{n:"Milk", q:2}], unlocked: false },
            { id: 3, name: "Spicy Honey Coffee", base: "Coffee", adds: [{n:"Honey", q:1}, {n:"Sliced Ginger", q:2}], unlocked: false },
            { id: 4, name: "Iced Lemon Tea", base: "Earl Grey", adds: [{n:"Sliced Lemon", q:1}, {n:"Ice", q:2}], unlocked: false },
            { id: 5, name: "Winter Warmer", base: "Coffee", adds: [{n:"Cinnamon", q:1}, {n:"Milk", q:1}, {n:"Sugar", q:1}], unlocked: false },
            { id: 6, name: "Hot Cocoa", base: "Hot Cocoa", adds: [{n:"Milk", q:1}], unlocked: false }
        ];
        
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0, 0);

        let audioCtx;
        const activeTweens = [];

        // DOM Elements
        const blocker = document.getElementById('blocker');
        const interactionPrompt = document.getElementById('interaction-prompt');
        const messageLog = document.getElementById('message-log');
        const currentOrderCard = document.getElementById('current-order-card');
        const recipeTarget = document.getElementById('recipe-target');
        const scoreVal = document.getElementById('score-val');
        const taskList = document.getElementById('task-list');
        const recipeModal = document.getElementById('recipe-modal');
        const recipeListContainer = document.getElementById('recipe-list-container');
        const recipeBtn = document.getElementById('recipe-collection-btn');
        const closeModalBtn = document.getElementById('close-modal-btn');

        // Styles
        const outlineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 3 });

        // --- Initialization ---
        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xddccaa); 
            scene.fog = new THREE.Fog(0xddccaa, 1, 30);
            scene.add(environmentGroup);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            initControls();
            setupLighting();
            buildRoom();
            buildDecorations();
            buildFurniture();
            
            // Initial Items
            createRecipeBook(6, 1.05, 6.5);
            
            // Moved bucket to the front end of the thick table (Counter)
            createSlopBucket(-8, 0, -3.5);
            
            // Moved Plaque to eye level, unobtrusive
            createCreditsPlaque(-14.9, 1.6, -12);

            // Feature: Retro Radio moved to the back wall end of the thick table (Counter)
            createRadio(-8, 1.35, -14.5);
            
            // Feature: Chopping Board
            createChoppingBoard(-9.2, 1.26, -10);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousedown', onMouseDown);
            
            updateRecipeCollectionUI();
        }

        function initControls() {
            camera.rotation.order = 'YXZ'; 

            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'KeyE': handleInteractionKey(); break;
                    case 'KeyR': toggleRecipeModal(); break;
                    case 'ShiftLeft': 
                    case 'ShiftRight': isSprinting = true; break;
                    case 'ControlLeft':
                    case 'ControlRight': isCrouching = true; break;
                    case 'Space': 
                        if (canJump) {
                            velocity.y = JUMP_FORCE;
                            canJump = false;
                        }
                        break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'ShiftLeft': 
                    case 'ShiftRight': isSprinting = false; break;
                    case 'ControlLeft':
                    case 'ControlRight': isCrouching = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            blocker.addEventListener('click', function () {
                document.body.requestPointerLock();
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            });

            document.addEventListener('pointerlockchange', function () {
                blocker.style.display = (document.pointerLockElement === document.body) ? 'none' : 'flex';
            });

            document.body.addEventListener('mousemove', function (event) {
                if (document.pointerLockElement === document.body) {
                    camera.rotation.y -= event.movementX * 0.002;
                    camera.rotation.x -= event.movementY * 0.002;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                }
            });
            
            recipeBtn.onclick = toggleRecipeModal;
            closeModalBtn.onclick = toggleRecipeModal;
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffddaa, 0.4);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffeedd, 0.6);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.bias = -0.0005; 
            scene.add(dirLight);
        }

        // --- Factories ---
        function applyStyle(mesh, color, addOutline = true, map = null, transparent = false, opacity = 1.0) {
            mesh.material = new THREE.MeshToonMaterial({
                color: color, map: map, gradientMap: null,
                transparent: transparent, opacity: opacity, side: THREE.DoubleSide
            });
            mesh.castShadow = !transparent;
            mesh.receiveShadow = true;
            if (addOutline && mesh.geometry && !transparent) {
                const edges = new THREE.EdgesGeometry(mesh.geometry, 25);
                const line = new THREE.LineSegments(edges, outlineMaterial);
                mesh.add(line);
            }
            return mesh;
        }
        
        function createChoppingBoard(x, y, z) {
            const group = new THREE.Group(); group.position.set(x, y, z);
            const board = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.8));
            applyStyle(board, 0x8b5a2b); group.add(board);
            
            // Knife
            const knifeGroup = new THREE.Group(); knifeGroup.position.set(0.4, 0.05, -0.3); knifeGroup.rotation.y = 0.5;
            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.04, 0.25, 8)); 
            handle.rotation.z = Math.PI/2; handle.position.x = 0.35;
            applyStyle(handle, 0x221100); knifeGroup.add(handle);
            
            const bladeShape = new THREE.Shape();
            bladeShape.moveTo(0, 0);
            bladeShape.lineTo(0.4, 0);
            bladeShape.lineTo(0.4, 0.08);
            bladeShape.lineTo(0, 0.06);
            bladeShape.lineTo(0, 0);
            const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, { depth: 0.01, bevelEnabled: false });
            const blade = new THREE.Mesh(bladeGeo);
            blade.material = new THREE.MeshToonMaterial({color: 0xdddddd, side: THREE.DoubleSide});
            blade.position.set(-0.1, -0.04, -0.005);
            
            const edges = new THREE.EdgesGeometry(bladeGeo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
            blade.add(line);
            
            knifeGroup.add(blade);
            group.add(knifeGroup);

            group.userData = { type: "chopping_board", name: "Chopping Board", storedItem: null, knife: knifeGroup };
            scene.add(group); interactables.push(group); collidableObjects.push({box: new THREE.Box3().setFromObject(group)});
        }

        function createTeacup(x, y, z) {
            const group = new THREE.Group(); group.position.set(x, y, z);
            const points = [new THREE.Vector2(0,0), new THREE.Vector2(0.12,0), new THREE.Vector2(0.15,0.25), new THREE.Vector2(0.13,0.25), new THREE.Vector2(0.10,0.02), new THREE.Vector2(0,0.02)];
            const cup = new THREE.Mesh(new THREE.LatheGeometry(points, 16)); 
            cup.material = new THREE.MeshToonMaterial({color:0xffffff, side:THREE.DoubleSide}); cup.castShadow=true; group.add(cup);
            const line = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.CylinderGeometry(0.15,0.12,0.25,16,1,true)), outlineMaterial); line.position.y=0.125; group.add(line);
            const lGroup = new THREE.Group(); lGroup.position.y=0.025; group.add(lGroup);
            const liquid = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.09,0.20,16), new THREE.MeshToonMaterial({color:0x88ccff, transparent:true, opacity:0.8})); liquid.position.y=0.10; lGroup.add(liquid);
            lGroup.scale.y=0; lGroup.visible=false;
            group.userData = { type:"cup", liquidGroup:lGroup, liquidMesh:liquid, flavor:"Empty", ingredients:[], isEmpty:true, temperature:"cold" };
            scene.add(group); interactables.push(group);
        }

        function createTeapot(x, y, z, color) {
            const group = new THREE.Group(); group.position.set(x,y,z);
            const body = new THREE.Mesh(new THREE.DodecahedronGeometry(0.3)); applyStyle(body,color); body.position.y=0.3; group.add(body);
            const spout = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.3)); applyStyle(spout,color); spout.position.set(0.25,0.4,0); spout.rotation.z=-Math.PI/4; group.add(spout);
            const handle = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.05,0.1)); applyStyle(handle,0x222222); handle.position.set(-0.3,0.4,0); handle.rotation.z=Math.PI/4; group.add(handle);
            const sMat = new THREE.MeshBasicMaterial({color:0x88ccff, opacity:0.6, transparent:true});
            const stream = new THREE.Mesh(new THREE.CylinderGeometry(0.015,0.015,1.5), sMat); stream.position.set(0.5,-0.2,0); stream.visible=false; group.add(stream);
            group.userData = { type:"pot", fillLevel:5, stream:stream }; scene.add(group); interactables.push(group);
        }

        function createIngredient(x, y, z, name, color, shape="box") {
            const group = new THREE.Group(); group.position.set(x, y, z);
            let mesh;
            if (shape === "bottle") {
                mesh = new THREE.Group();
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.4, 16)); body.position.y=0.2; applyStyle(body, 0x88ccff, false, null, true, 0.3); mesh.add(body);
                const milk = new THREE.Mesh(new THREE.CylinderGeometry(0.11, 0.11, 0.35, 16)); milk.position.y=0.18; applyStyle(milk, 0xffffff, false); mesh.add(milk);
                const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.12, 0.15, 16)); neck.position.y = 0.475; applyStyle(neck, 0x88ccff, false, null, true, 0.3); mesh.add(neck);
            } else if (shape === "jar_white") {
                mesh = new THREE.Group();
                const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.12, 0.3, 16)); pot.position.y=0.15; applyStyle(pot, 0xffffff); mesh.add(pot);
                const lid = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.16, 0.05, 16)); lid.position.y = 0.17; applyStyle(lid, 0x664422); mesh.add(lid);
            } else if (shape === "honey_jar") {
                mesh = new THREE.Group();
                const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.14, 0.3, 16)); pot.position.y=0.15; applyStyle(pot, 0xffaa00, true, null, true, 0.8); mesh.add(pot);
                const lid = new THREE.Mesh(new THREE.CylinderGeometry(0.13, 0.13, 0.03, 16)); lid.position.y = 0.16; applyStyle(lid, 0x443322); mesh.add(lid);
            } else if (shape === "canister") {
                mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.35, 16)); mesh.position.y=0.175; applyStyle(mesh, color);
                const lid = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.16, 0.05, 16)); lid.position.y = 0.375; applyStyle(lid, 0x222222); mesh.add(lid);
            } else if (shape === "sack") {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 0.2)); mesh.position.y=0.2; mesh.scale.set(1, 0.9, 0.8); applyStyle(mesh, color, true, createSackTexture());
            } else if (shape === "lemon") {
                mesh = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12)); mesh.scale.x = 1.4; mesh.position.y = 0.15; applyStyle(mesh, color);
                name = "Whole Lemon"; 
            } else if (shape === "ice") {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2)); applyStyle(mesh, color, true, null, true, 0.6);
            } else if (shape === "ginger") {
                mesh = new THREE.Group();
                const b1 = new THREE.Mesh(new THREE.SphereGeometry(0.1)); b1.position.y=0.1; applyStyle(b1, color, false); mesh.add(b1);
                const b2 = new THREE.Mesh(new THREE.SphereGeometry(0.08)); b2.position.set(0.1, 0.1, 0); applyStyle(b2, color, false); mesh.add(b2);
                name = "Whole Ginger"; 
            } else if (shape === "cinnamon") {
                mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.3)); mesh.position.y=0.03; mesh.rotation.z = Math.PI/2; applyStyle(mesh, color);
            } else if (shape === "mint") {
                mesh = new THREE.Group();
                for(let i=0; i<3; i++) {
                    const leaf = new THREE.Mesh(new THREE.CircleGeometry(0.08, 6));
                    leaf.rotation.x = -Math.PI/2; leaf.rotation.y = Math.random(); leaf.position.set(Math.random()*0.1, 0.01, Math.random()*0.1);
                    applyStyle(leaf, color, false); leaf.material.side = THREE.DoubleSide; mesh.add(leaf);
                }
            } else {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 0.2)); mesh.position.y=0.2; applyStyle(mesh, color);
            }
            group.add(mesh);
            
            group.userData = { 
                type: "ingredient", 
                name: name, 
                color: color,
                spawnParams: { x:x, y:y, z:z, name:name, color:color, shape:shape }
            };
            
            scene.add(group); interactables.push(group);
            return group;
        }

        function createPlant(x, y, z) {
            const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.3, 0.5, 8)); applyStyle(pot, 0xaa5522); pot.position.set(x, y + 0.25, z); environmentGroup.add(pot); collidableObjects.push({box: new THREE.Box3().setFromObject(pot)});
            const stem = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 0.1)); applyStyle(stem, 0x228b22); stem.position.set(0, 0.5, 0); pot.add(stem);
        }

        function createRecipeBook(x, y, z) {
            const group = new THREE.Group(); group.position.set(x, y, z);
            const book = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.1, 0.8)); applyStyle(book, 0x884422); group.add(book);
            const page = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.7), new THREE.MeshBasicMaterial({color: 0xffffff})); page.rotation.x = -Math.PI/2; page.position.y = 0.06; group.add(page);
            group.userData = { type: "recipe_book", name: "Recipe List" }; scene.add(group); interactables.push(group);
        }

        function createSlopBucket(x, y, z) {
            const group = new THREE.Group(); group.position.set(x, y, z);
            const bucket = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.3, 0.6, 16)); applyStyle(bucket, 0x555555); bucket.position.y = 0.3; group.add(bucket);
            const slop = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.25, 0.5, 16), new THREE.MeshToonMaterial({color: 0x332211})); slop.position.y = 0.3; group.add(slop);
            group.userData = { type: "slop_bucket", name: "Slop Bucket", isStatic: true }; 
            scene.add(group); interactables.push(group); collidableObjects.push({box: new THREE.Box3().setFromObject(group)});
        }

        function createMicrowave(x, y, z) {
            const group = new THREE.Group(); group.position.set(x, y, z);
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, 1.0));
            applyStyle(body, 0xdddddd); body.position.y = 0.4; group.add(body);
            const win = new THREE.Mesh(new THREE.PlaneGeometry(1.0, 0.5));
            win.material = new THREE.MeshBasicMaterial({color: 0x222222});
            win.position.set(0, 0.4, 0.51); group.add(win);
            const light = new THREE.PointLight(0xffffaa, 0, 2);
            light.position.set(0, 0.4, 0); group.add(light);
            group.userData = { type: "microwave", name: "Microwave", isStatic: true, light: light, isRunning: false };
            scene.add(group); interactables.push(group); collidableObjects.push({box: new THREE.Box3().setFromObject(group)});
        }

        function createBambooTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#dcb165'; 
            ctx.fillRect(0, 0, 512, 512);
            for(let i=0; i<512; i+=20) {
                 ctx.fillStyle = (i%40===0) ? '#cca055' : '#eec377'; 
                 ctx.fillRect(i, 0, 18, 512); 
                 ctx.fillStyle = '#8b5a2b'; 
                 ctx.fillRect(i+18, 0, 2, 512);
                 ctx.fillStyle = 'rgba(100,80,50,0.2)';
                 if(Math.random()>0.4) {
                     const y = Math.random()*512;
                     ctx.fillRect(i, y, 18, 6);
                 }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createWoodTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#555555'; ctx.fillRect(0,0,512,512);
            ctx.strokeStyle = '#444444'; ctx.lineWidth = 4; ctx.beginPath();
            for(let y=0; y<512; y+=128) { ctx.moveTo(0,y); ctx.lineTo(512,y); }
            for(let x=0; x<512; x+=128) { ctx.moveTo(x,0); ctx.lineTo(x,512); }
            ctx.stroke();
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(4, 4);
            return tex;
        }

        function createSackTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#8b5a2b'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            for(let i=0; i<400; i++) ctx.fillRect(Math.random()*128, Math.random()*128, 2, 2);
            return new THREE.CanvasTexture(canvas);
        }

        function createBrightWindowTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            // Bright day sky gradient
            const grd = ctx.createLinearGradient(0, 0, 0, 128);
            grd.addColorStop(0, "#ffffff");
            grd.addColorStop(1, "#aaddff");
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function createFlowerPaintingTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 340; 
            const ctx = canvas.getContext('2d');
            
            // Canvas/Paper Background
            ctx.fillStyle = '#f5e6d3'; 
            ctx.fillRect(0, 0, 512, 340);
            
            // Abstract background strokes (Oil paint effect)
            for(let i=0; i<150; i++) {
                ctx.fillStyle = `rgba(${180+Math.random()*50}, ${160+Math.random()*50}, ${130+Math.random()*50}, 0.3)`;
                ctx.fillRect(Math.random()*512, Math.random()*340, 20 + Math.random()*50, 20 + Math.random()*30);
            }

            // Green Stems/Leaves
            ctx.strokeStyle = '#2d5a27';
            ctx.lineCap = 'round';
            for(let i=0; i<12; i++) {
                ctx.lineWidth = 3 + Math.random() * 4;
                ctx.beginPath();
                const startX = 100 + Math.random() * 312;
                const startY = 340;
                ctx.moveTo(startX, startY);
                // Random organic curve
                ctx.quadraticCurveTo(
                    startX + (Math.random()-0.5)*150, 
                    startY - 150, 
                    startX + (Math.random()-0.5)*250, 
                    50 + Math.random()*150
                );
                ctx.stroke();
            }

            // Flowers (Impressionist blobs)
            const colors = ['#e63946', '#ffb703', '#fb8500', '#9d4edd', '#ff006e'];
            for(let i=0; i<25; i++) {
                ctx.fillStyle = colors[Math.floor(Math.random()*colors.length)];
                const cx = 50 + Math.random() * 412;
                const cy = 50 + Math.random() * 250;
                const r = 10 + Math.random() * 25;
                
                // Draw flower as collection of circles for texture
                for(let j=0; j<5; j++) {
                    ctx.beginPath();
                    ctx.arc(cx + (Math.random()-0.5)*r, cy + (Math.random()-0.5)*r, r*0.6, 0, Math.PI*2);
                    ctx.fill();
                }
                
                // Highlight
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.beginPath();
                ctx.arc(cx - r/3, cy - r/3, r/3, 0, Math.PI*2);
                ctx.fill();
            }
            
            // Simple frame border on the texture itself
            ctx.strokeStyle = '#4a3b2a';
            ctx.lineWidth = 20;
            ctx.strokeRect(0,0,512,340);

            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        function createCreditsPlaque(x, y, z) {
             const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 64;
             const ctx = canvas.getContext('2d');
             // Brass/Gold background
             ctx.fillStyle = '#aa8800'; ctx.fillRect(0,0,256,64);
             ctx.strokeStyle = '#442200'; ctx.lineWidth = 4; ctx.strokeRect(0,0,256,64);
             ctx.fillStyle = '#331100'; ctx.font = 'bold 20px Courier New'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
             ctx.fillText('made by mihnea_u', 128, 32);
             
             const tex = new THREE.CanvasTexture(canvas);
             // Smaller, thinner geometry
             const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.25, 1.0), new THREE.MeshBasicMaterial({map: tex}));
             mesh.position.set(x, y, z);
             environmentGroup.add(mesh);
        }
        
        function createRug(x, z) {
            const geo = new THREE.PlaneGeometry(8, 5);
            const canvas = document.createElement('canvas'); canvas.width=128; canvas.height=128;
            const ctx = canvas.getContext('2d');
            // Patterned Rug
            ctx.fillStyle = '#883333'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#cc5555'; ctx.fillRect(10,10,108,108);
            ctx.strokeStyle = '#551111'; ctx.lineWidth = 2; ctx.strokeRect(20,20,88,88);
            
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshToonMaterial({map: tex, color: 0xffffff});
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI/2;
            mesh.position.set(x, 0.02, z); // Slightly above floor to prevent z-fighting
            environmentGroup.add(mesh);
        }

        function buildRoom() {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(30, 30)); applyStyle(floor, 0x888888, false, createWoodTexture()); floor.rotation.x = -Math.PI / 2; 
            floor.position.y = 0.01; // Lift slightly to prevent Z-fighting
            environmentGroup.add(floor); 
            const bambooTex = createBambooTexture(); bambooTex.repeat.set(2, 1);
            const roomGeo = new THREE.BoxGeometry(30, 10, 30);
            const wallMat = new THREE.MeshToonMaterial({color: 0xffffff, map: bambooTex, side: THREE.BackSide});
            const room = new THREE.Mesh(roomGeo, wallMat); room.position.y = 5; environmentGroup.add(room);
            const walls = [{ pos: [0, 2.5, -15], dim: [30, 5, 1] }, { pos: [0, 2.5, 15], dim: [30, 5, 1] }, { pos: [-15, 2.5, 0], dim: [1, 5, 30] }, { pos: [15, 2.5, 0], dim: [1, 5, 30] }];
            walls.forEach(w => { const box = new THREE.Box3(); box.setFromCenterAndSize(new THREE.Vector3(...w.pos), new THREE.Vector3(...w.dim)); collidableObjects.push({box: box}); });
            
            const ceilingMat = new THREE.MeshToonMaterial({color: 0x3d2817, side: THREE.BackSide});
            const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(30, 30), ceilingMat);
            ceiling.rotation.x = Math.PI/2; ceiling.position.y = 10; environmentGroup.add(ceiling);

            // -- Painting Update & More Windows --
            const winGeo = new THREE.PlaneGeometry(6, 4);
            const paintTex = createFlowerPaintingTexture();
            const winMat = new THREE.MeshBasicMaterial({ map: paintTex });
            
            // Left Wall Window (Painting)
            const win1 = new THREE.Mesh(winGeo, winMat); 
            win1.position.set(-14.88, 3, 0); 
            win1.rotation.y = Math.PI / 2; 
            scene.add(win1);
            const frame1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4, 6)); applyStyle(frame1, 0x3d2817); frame1.position.set(-15, 3, 0); environmentGroup.add(frame1);

            // -- Right Wall: Opaque Windows (REMOVED LIGHT SHAFTS) --
            const brightTex = createBrightWindowTexture();
            const brightMat = new THREE.MeshBasicMaterial({ map: brightTex }); 

            // Right Window 1
            const win2 = new THREE.Mesh(winGeo, brightMat);
            win2.position.set(14.88, 5, -5); 
            win2.rotation.y = -Math.PI / 2;
            scene.add(win2);
            const frame2 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4, 6)); applyStyle(frame2, 0x3d2817); frame2.position.set(15, 5, -5); environmentGroup.add(frame2);

            // Right Window 2
            const win3 = new THREE.Mesh(winGeo, brightMat);
            win3.position.set(14.88, 5, 5);
            win3.rotation.y = -Math.PI / 2;
            scene.add(win3);
            const frame3 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4, 6)); applyStyle(frame3, 0x3d2817); frame3.position.set(15, 5, 5); environmentGroup.add(frame3);
        }

        function createRectangularLantern(x, y, z) {
            const group = new THREE.Group(); group.position.set(x, y, z);
            const frameGeo = new THREE.BoxGeometry(0.8, 1.2, 0.8);
            const frameMat = new THREE.MeshToonMaterial({ color: 0x3d2817 });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            group.add(frame);
            const edges = new THREE.EdgesGeometry(frameGeo);
            const line = new THREE.LineSegments(edges, outlineMaterial);
            group.add(line);

            const paperGeo = new THREE.BoxGeometry(0.7, 1.1, 0.7);
            const paperMat = new THREE.MeshBasicMaterial({ color: 0xffffee }); 
            const paper = new THREE.Mesh(paperGeo, paperMat);
            group.add(paper);
            
            // Bulb
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), new THREE.MeshBasicMaterial({color: 0xffffaa}));
            bulb.position.y = 0;
            group.add(bulb);
            
            const light = new THREE.PointLight(0xffaa55, 0.5, 8);
            light.position.y = -0.5;
            group.add(light);

            const cord = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 2), new THREE.MeshBasicMaterial({color: 0x111111}));
            cord.position.y = 1.6;
            group.add(cord);

            environmentGroup.add(group);
        }

        function createMenuBoards() {
            const startZ = -14; 
            for(let i=0; i<4; i++) {
                const board = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 2));
                applyStyle(board, 0xffffff); 
                board.position.set(-14.8, 6, startZ + (i * 2.5));
                const frame = new THREE.Mesh(new THREE.BoxGeometry(0.12, 1.6, 2.1));
                applyStyle(frame, 0xdcb165); 
                frame.position.set(-14.85, 6, startZ + (i * 2.5));
                environmentGroup.add(frame);
                environmentGroup.add(board);
            }
        }

        function createHangingVines() {
            // Existing corners
            const corners = [[-14, 9, -14], [-14, 9, 14], [14, 9, -14], [14, 9, 14]];
            
            // Add random spots across the room
            for(let i=0; i<12; i++) {
                corners.push([
                    (Math.random() * 20) - 10, // x between -10 and 10
                    9,
                    (Math.random() * 24) - 12  // z between -12 and 12
                ]);
            }

            corners.forEach(p => {
                const group = new THREE.Group(); group.position.set(...p);
                for(let i=0; i<15; i++) {
                    const leaf = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4));
                    applyStyle(leaf, 0x228b22);
                    leaf.position.set(Math.random()*2-1, -Math.random()*3, Math.random()*2-1);
                    group.add(leaf);
                }
                environmentGroup.add(group);
            });
        }

        function buildDecorations() {
            createRectangularLantern(0, 7, 0); createRectangularLantern(6, 7, 6); createRectangularLantern(6, 7, -6); createRectangularLantern(-6, 7, 6); createRectangularLantern(-8, 7, -10); 
            for(let z=-12; z<=12; z+=4) { const b=new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,30)); b.rotation.z=Math.PI/2; applyStyle(b,0x8b5a2b); b.position.set(0,9.8,z); environmentGroup.add(b); }
            createMenuBoards();
            createHangingVines();
            createRug(0, 0);
        }

        function buildFurniture() {
            createCounter(-8, 0, -10);
            createBackCounter(-13, 0, -10);
            createTableSet(0, 0, 0); createTableSet(6, 0, 6); createTableSet(6, 0, -6); createTableSet(-6, 0, 6);
            createPlant(12, 0, 12);
        }

        function createCounter(x, y, z) {
            const w=4; const h=1.2; const d=12; 
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d));
            const bambooTex = createBambooTexture();
            mesh.material = new THREE.MeshToonMaterial({ color: 0xffffff, map: bambooTex });
            mesh.castShadow = true; mesh.receiveShadow = true;
            mesh.position.set(x, h/2, z);
            environmentGroup.add(mesh); collidableObjects.push({box: new THREE.Box3().setFromObject(mesh)});
            
            const top = new THREE.Mesh(new THREE.BoxGeometry(w+0.2, 0.1, d+0.2)); applyStyle(top, 0xcccccc); top.position.set(x, h+0.05, z); environmentGroup.add(top);
            
            const signBack = new THREE.Mesh(new THREE.CylinderGeometry(1.5,1.5,0.1,32)); signBack.rotation.z=Math.PI/2; signBack.position.set(x+w/2+0.05, h/2, z); applyStyle(signBack, 0x3d2817); environmentGroup.add(signBack);
            const signFace = new THREE.Mesh(new THREE.CylinderGeometry(1.3,1.3,0.12,32)); signFace.rotation.z=Math.PI/2; signFace.position.set(x+w/2+0.05, h/2, z); signFace.material=new THREE.MeshBasicMaterial({color:0xffffee}); environmentGroup.add(signFace);
            const t1 = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.2, 0.1)); t1.position.set(x+w/2+0.12, h/2+0.5, z); t1.rotation.y=Math.PI/2; environmentGroup.add(t1);
            
            createTeapot(x+1, h, z+2, 0xff6666);
        }

        function createBackCounter(x, y, z) {
            const h = 1.1; 
            const top = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 12));
            applyStyle(top, 0x5c4033); top.position.set(x, h - 0.05, z);
            environmentGroup.add(top);
            collidableObjects.push({box: new THREE.Box3().setFromObject(top)});

            const legH = h - 0.1;
            const legGeo = new THREE.BoxGeometry(1.8, legH, 0.1);
            const lLeg = new THREE.Mesh(legGeo, new THREE.MeshToonMaterial({color: 0x5c4033})); lLeg.position.set(x, legH/2, z-5.9); environmentGroup.add(lLeg);
            const rLeg = new THREE.Mesh(legGeo, new THREE.MeshToonMaterial({color: 0x5c4033})); rLeg.position.set(x, legH/2, z+5.9); environmentGroup.add(rLeg);
            const back = new THREE.Mesh(new THREE.BoxGeometry(0.1, legH, 11.8), new THREE.MeshToonMaterial({color: 0x5c4033})); back.position.set(x-0.85, legH/2, z); environmentGroup.add(back);

            const shelfY = 0.4;
            const shelf = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.1, 11.8));
            applyStyle(shelf, 0x4a332a); shelf.position.set(x, shelfY, z);
            environmentGroup.add(shelf);

            const baseBox = new THREE.Box3(); baseBox.min.set(x-1,0,z-6); baseBox.max.set(x+1,h-0.1,z+6); collidableObjects.push({box: baseBox});
            
            createIngredient(x, h, z+4, "Matcha", 0x88cc44, "canister");
            createIngredient(x, h, z+3, "Coffee", 0x442211, "sack");
            createIngredient(x, h, z+2, "Cocoa", 0x553311, "canister"); 
            createIngredient(x, h, z+1, "Earl Grey", 0x444488, "box");
            createIngredient(x, h, z-1, "Milk", 0xffffff, "bottle");
            createIngredient(x, h, z-2, "Sugar", 0xeeeeee, "jar_white");
            createIngredient(x, h, z-3, "Cinnamon", 0x884422, "cinnamon");
            createIngredient(x, h, z-4, "Honey", 0xffaa00, "honey_jar");
            
            createMicrowave(x, h, z-5);
            
            const cupY = shelfY + 0.05; 
            const cupX = x + 0.4; 
            createIngredient(cupX, cupY, z+2, "Lemon", 0xffff00, "lemon");
            createIngredient(cupX, cupY, z-2, "Mint", 0x44aa44, "mint");
            createIngredient(cupX, cupY, z, "Ice", 0xaaddff, "ice");
            createIngredient(cupX, cupY, z+3.5, "Ginger", 0xeeddcc, "ginger");
        }

        function createTableSet(x, y, z) {
            const h = 1.0;
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, h)); applyStyle(leg, 0xdcb165); leg.position.set(x, y + h/2, z); environmentGroup.add(leg);
            const top = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 2.5)); applyStyle(top, 0xdcb165); top.position.set(x, y + h, z); environmentGroup.add(top);
            const tableBox = new THREE.Box3().setFromObject(top); tableBox.min.y = 0; collidableObjects.push({box: tableBox});
            createChair(x - 2, y, z, Math.PI/2); createChair(x + 2, y, z, -Math.PI/2);
            if (Math.random() > 0.3) { createTeacup(x - 0.5, h + 0.05, z); createTeacup(x + 0.5, h + 0.05, z); }
        }

        function createChair(x, y, z, rot) {
            const group = new THREE.Group(); group.position.set(x, y, z); group.rotation.y = rot;
            const bambooColor = 0xdcb165;
            const seat = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.1, 1.0)); applyStyle(seat, bambooColor); seat.position.y = 0.6; group.add(seat);
            const back = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.0, 1.0)); applyStyle(back, bambooColor); back.position.set(-0.45, 1.1, 0); group.add(back);
            const l1 = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.6)); applyStyle(l1, bambooColor); l1.position.set(0.4, 0.3, 0.4); group.add(l1);
            const l2 = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.6)); applyStyle(l2, bambooColor); l2.position.set(-0.4, 0.3, 0.4); group.add(l2);
            const l3 = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.6)); applyStyle(l3, bambooColor); l3.position.set(0.4, 0.3, -0.4); group.add(l3);
            const l4 = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.6)); applyStyle(l4, bambooColor); l4.position.set(-0.4, 0.3, -0.4); group.add(l4);
            environmentGroup.add(group); collidableObjects.push({box: new THREE.Box3().setFromObject(group)});
        }

        // --- NEW FEATURE LOGIC ---

        function generateRecipe() {
            // FIX: Ensure we pick a new recipe distinct from the current one
            let newRecipe;
            do {
                newRecipe = ALL_RECIPES[Math.floor(Math.random() * ALL_RECIPES.length)];
            } while (currentRecipe && newRecipe.id === currentRecipe.id && ALL_RECIPES.length > 1);
            
            currentRecipe = newRecipe;
            updateHUDOrder();
            currentOrderCard.classList.remove('flash');
            void currentOrderCard.offsetWidth; // Trigger reflow
            currentOrderCard.classList.add('flash');
        }

        // Radio Features (Code same as previous, ensured presence)
        function createRadio(x, y, z) {
            const group = new THREE.Group(); group.position.set(x, y, z);
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 0.3)); applyStyle(body, 0x8b4513); group.add(body); 
            const face = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.4, 0.05)); applyStyle(face, 0xddccaa); face.position.set(0, 0, 0.13); group.add(face);
            const grill = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.06)); applyStyle(grill, 0x444444); grill.position.set(-0.15, 0, 0.13); group.add(grill);
            const antBase = new THREE.Mesh(new THREE.SphereGeometry(0.05)); applyStyle(antBase, 0x888888); antBase.position.set(-0.3, 0.25, 0); group.add(antBase);
            const ant = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.02, 0.8)); applyStyle(ant, 0x888888); ant.position.set(-0.3, 0.65, 0); group.add(ant);
            
            group.userData = { type: "radio", name: "Retro Radio" };
            scene.add(group); interactables.push(group); collidableObjects.push({box: new THREE.Box3().setFromObject(group)});
        }

        function toggleRadio() {
            radioState = (radioState + 1) % 3;
            const states = ["Off", "Chill Beats", "Piano Vibes"];
            showMessage(`Radio: ${states[radioState]}`);
            playSound(400 + (radioState*100), 400 + (radioState*100), 0.1);
        }

        function updateRadio(time) {
            if (radioState === 0 || !audioCtx) return;
            if (time > nextNoteTime) {
                const chords = radioState === 1 ? [261.6, 311.1, 392.0, 466.2] : [329.6, 392.0, 493.9, 587.3];
                const note = chords[Math.floor(Math.random() * chords.length)] / (Math.random() > 0.8 ? 2 : 1);
                const dur = radioState === 1 ? 2.0 : 3.0;
                
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                filter.type = "lowpass"; filter.frequency.value = 800;

                osc.type = radioState === 1 ? 'triangle' : 'sine';
                osc.frequency.setValueAtTime(note, audioCtx.currentTime);
                gain.gain.setValueAtTime(0, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);

                osc.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + dur);
                nextNoteTime = time + (radioState === 1 ? 800 : 1500) + Math.random() * 500;
            }
        }

        function createSteamParticle(pos) {
            const el = new THREE.Mesh(new THREE.CircleGeometry(0.05, 8), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.3, side:THREE.DoubleSide}));
            el.position.copy(pos); el.position.y += 0.2;
            el.lookAt(camera.position);
            scene.add(el);
            steamParticles.push({mesh:el, life:1.0, velocity:new THREE.Vector3((Math.random()-0.5)*0.01, 0.02, (Math.random()-0.5)*0.01)});
        }

        function updateSteam(delta) {
            if (Math.random() > 0.85) {
                interactables.forEach(obj => {
                    if (obj.userData.type === 'cup' && !obj.userData.isEmpty && (obj.userData.ingredients.includes('Hot Water') || (obj.userData.flavor && (obj.userData.flavor.includes('Hot') || obj.userData.flavor.includes('Warm'))))) {
                        createSteamParticle(obj.position);
                    } else if (obj.userData.type === 'pot') { 
                        createSteamParticle(obj.position);
                    }
                });
            }
            for (let i = steamParticles.length - 1; i >= 0; i--) {
                const p = steamParticles[i];
                p.life -= delta * 0.8;
                p.mesh.position.add(p.velocity);
                p.mesh.material.opacity = p.life * 0.3;
                p.mesh.lookAt(camera.position);
                if (p.life <= 0) { scene.remove(p.mesh); steamParticles.splice(i, 1); }
            }
        }

        function updateHUDOrder() {
            if(!currentRecipe) return;
            let html = `<div class="recipe-name">${currentRecipe.name}</div>`;
            html += `<div class="recipe-item">Base: ${currentRecipe.base}</div>`;
            if(currentRecipe.adds.length > 0) {
                // REPAIR: Show Quantities in HUD
                const addList = currentRecipe.adds.map(a => `${a.n} x${a.q}`).join(", ");
                html += `<div class="recipe-item">Add: ${addList}</div>`;
            }
            recipeTarget.innerHTML = html;
        }

        function checkRecipe(cupContents) {
            if (!currentRecipe || !hasRecipeBook) return;
            const meaningfulIngredients = cupContents.filter(i => i !== "Hot Water");
            
            // Count ingredients in cup
            const cupCounts = {};
            meaningfulIngredients.forEach(i => {
                // Normalize Base names
                let name = i;
                if(i.includes("Matcha")) name = "Matcha"; 
                else if(i.includes("Coffee")) name = "Coffee"; 
                else if(i.includes("Earl")) name = "Earl Grey";
                cupCounts[name] = (cupCounts[name] || 0) + 1;
            });

            // Check Base
            const hasBase = cupCounts[currentRecipe.base] >= 1;
            
            // Check Adds Quantities
            let hasAllAdds = true;
            let requiredTotal = 1; // 1 for base
            
            currentRecipe.adds.forEach(req => {
                requiredTotal += req.q;
                if ((cupCounts[req.n] || 0) !== req.q) hasAllAdds = false;
            });

            // Total count check
            const countMatch = meaningfulIngredients.length === requiredTotal;

            if (hasBase && hasAllAdds && countMatch) {
                score++; scoreVal.innerText = score; playSound(600, 1000, 0.5, 'square'); showMessage("Order Perfect! Recipe logged.");
                if (!currentRecipe.unlocked) { currentRecipe.unlocked = true; showMessage("NEW RECIPE UNLOCKED!"); updateRecipeCollectionUI(); }
                if (score === 1) updateTaskList(2);
                setTimeout(generateRecipe, 2000); 
            } else { showMessage("That doesn't taste like the order..."); }
        }

        function updateRecipeCollectionUI() {
            recipeListContainer.innerHTML = "";
            ALL_RECIPES.forEach(r => {
                const div = document.createElement('div'); div.className = "recipe-entry";
                if (r.unlocked) {
                    const addStr = r.adds.map(a => `${a.n} x${a.q}`).join(", ");
                    div.innerHTML = `<span class="recipe-name">${r.name}</span><span class="recipe-ingredients">${r.base}, ${addStr}</span>`;
                }
                else div.innerHTML = `<span class="recipe-name locked">??????</span><span class="recipe-ingredients locked">Locked</span>`;
                recipeListContainer.appendChild(div);
            });
        }

        function toggleRecipeModal() {
            if (!hasRecipeBook) return;
            isRecipeModalOpen = !isRecipeModalOpen;
            recipeModal.style.display = isRecipeModalOpen ? 'block' : 'none';
            if (isRecipeModalOpen) document.exitPointerLock();
            else document.body.requestPointerLock();
        }

        function updateTaskList(step) {
            const task1 = document.getElementById('task-1'); 
            const task2 = document.getElementById('task-2');
            if (step === 1) { 
                task1.querySelector('.task-checkbox').classList.add('task-checked'); 
                task1.style.textDecoration = "line-through"; 
                task1.style.opacity = 0.5;
                task2.style.opacity = 1.0; 
                task2.innerHTML = `<span class="task-checkbox"></span>Complete Order`;
                generateRecipe();
            } else if (step === 2) { 
                task2.querySelector('.task-checkbox').classList.add('task-checked'); 
                task2.style.textDecoration = "line-through"; 
                setTimeout(() => { taskList.style.opacity = 0; }, 2000);
            }
        }

        function getLookingAt() {
            raycaster.setFromCamera(center, camera);
            const hits = raycaster.intersectObjects(interactables, true);
            if (hits.length > 0) {
                let obj = hits[0].object; 
                while(obj.parent && !obj.userData.type && obj.parent !== scene) obj = obj.parent;
                if (obj.userData.type && hits[0].distance < INTERACTION_DISTANCE) return { type: 'item', obj: obj, dist: hits[0].distance };
            }
            const envHits = raycaster.intersectObjects(environmentGroup.children, true);
            if (envHits.length > 0) {
                for (let i = 0; i < envHits.length; i++) {
                    const hit = envHits[i];
                    if (hit.distance > INTERACTION_DISTANCE) break;
                    if (hit.face && hit.face.normal && hit.face.normal.y > 0.8) return { type: 'surface', point: hit.point, dist: hit.distance };
                }
            }
            return null;
        }

        function handleInteractionKey() {
            if (isAnimatingAction) return;
            const target = getLookingAt();
            if (heldItem) {
                if (target && target.type === 'surface') { dropItem(target.point); playSound(100, 50, 0.1); } 
                else if (target && target.type === 'item') {
                    const tType = target.obj.userData.type; const hType = heldItem.userData.type;
                    if (hType === 'ingredient' && tType === 'cup') mixIngredient(target.obj, heldItem);
                    else if (hType === 'cup' && tType === 'slop_bucket') emptyCup(heldItem);
                    else if (hType === 'cup' && tType === 'microwave') useMicrowave(target.obj, heldItem);
                    // FEATURE: Chopping Interaction
                    else if (tType === 'chopping_board') useChoppingBoard(target.obj, heldItem);
                    else showMessage("Can't combine these.");
                } 
                else showMessage("Can't place here.");
            } else {
                if (target && target.type === 'item') {
                    if (target.obj.userData.type === "recipe_book") {
                        if(!hasRecipeBook) { hasRecipeBook=true; currentOrderCard.style.display='block'; recipeBtn.style.display='block'; updateTaskList(1); showMessage("Recipe List acquired! Press R."); target.obj.visible=false; playSound(300, 600, 0.1); }
                    } else if (target.obj.userData.type === "microwave") { activateMicrowave(target.obj); }
                    else if (target.obj.userData.type === "radio") { toggleRadio(); } 
                    // FEATURE: Chopping Board Empty Interaction
                    else if (target.obj.userData.type === "chopping_board") useChoppingBoard(target.obj, null);
                    else if (target.obj.userData.isStatic) showMessage("That stays there.");
                    else { pickUpItem(target.obj); playSound(200, 400, 0.1); }
                }
            }
        }

        // FEATURE: Chopping Board Logic
        function useChoppingBoard(board, item) {
            // 1. Place Item
            if (item && !board.userData.storedItem) {
                if(item.userData.type !== 'ingredient') { showMessage("Can only chop ingredients."); return; }
                camera.remove(item);
                board.add(item); item.position.set(0, 0.1, 0); item.rotation.set(0,0,0);
                board.userData.storedItem = item; heldItem = null;
                showMessage("Placed on board.");
                return;
            }
            // 2. Chop Item
            if (!item && board.userData.storedItem) {
                const stored = board.userData.storedItem;
                if (stored.userData.name.includes("Whole")) {
                    isAnimatingAction = true;
                    // Animate Knife
                    const k = board.userData.knife;
                    const startRot = k.rotation.z;
                    const startPos = k.position.y;
                    
                    // Chop animation loop
                    let chops = 0;
                    const chopInterval = setInterval(() => {
                        k.position.y = startPos + 0.1;
                        k.rotation.z = -0.2;
                        setTimeout(() => {
                            k.position.y = startPos;
                            k.rotation.z = startRot;
                            playSound(500 + Math.random()*200, 100, 0.05, 'sawtooth');
                        }, 50);
                        chops++;
                        if(chops >= 3) {
                            clearInterval(chopInterval);
                            finishChopping();
                        }
                    }, 150);

                    function finishChopping() {
                        isAnimatingAction = false;
                        const originalName = stored.userData.name;
                        
                        // Replace model with Sliced version
                        stored.children = []; // Remove old geometry
                        
                        if (originalName.includes("Lemon")) {
                            // Create 3 lemon slices
                            for(let i=0; i<3; i++) {
                                const slice = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.02, 16));
                                slice.rotation.x = Math.PI/2;
                                slice.rotation.z = Math.random();
                                slice.position.set((i-1)*0.1, 0.05, (Math.random()-0.5)*0.1);
                                applyStyle(slice, 0xffff00);
                                // Inner pith
                                const pith = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), new THREE.MeshBasicMaterial({color:0xffffee}));
                                pith.position.y = 0.011; pith.rotation.x = -Math.PI/2;
                                slice.add(pith);
                                stored.add(slice);
                            }
                            stored.userData.name = "Sliced Lemon";
                        } else if (originalName.includes("Ginger")) {
                            // Create chunks
                            for(let i=0; i<4; i++) {
                                const chunk = new THREE.Mesh(new THREE.DodecahedronGeometry(0.06));
                                chunk.position.set((Math.random()-0.5)*0.3, 0.05, (Math.random()-0.5)*0.2);
                                applyStyle(chunk, 0xeeddcc);
                                stored.add(chunk);
                            }
                            stored.userData.name = "Sliced Ginger";
                        } else {
                            // Fallback
                            stored.scale.set(0.8, 0.5, 0.8);
                            stored.userData.name = stored.userData.name.replace("Whole", "Sliced");
                        }
                        
                        showMessage("Sliced!");

                        // REPAIR: Respawn the original whole ingredient
                        if (stored.userData.spawnParams) {
                            const p = stored.userData.spawnParams;
                            createIngredient(p.x, p.y, p.z, p.name, p.color, p.shape);
                        }
                    }
                } else {
                    // 3. Pick Up Item
                    board.remove(stored);
                    board.userData.storedItem = null;
                    pickUpItem(stored);
                }
            } else if (item && board.userData.storedItem) {
                showMessage("Board is occupied.");
            }
        }

        function useMicrowave(microwave, cup) {
            if (microwave.userData.cup) { showMessage("Microwave is full."); return; }
            if (cup.userData.isEmpty) { showMessage("Cup is empty."); return; }
            camera.remove(cup); microwave.add(cup); cup.position.set(0, 0, 0); cup.scale.set(0.5, 0.5, 0.5); 
            microwave.userData.cup = cup; heldItem = null; showMessage("Put cup in microwave.");
        }

        function activateMicrowave(microwave) {
            if (!microwave.userData.cup) { showMessage("Microwave is empty."); return; }
            if (microwave.userData.isRunning) return;
            const cup = microwave.userData.cup; const ings = cup.userData.ingredients;
            let hasMilk = false; let hasCocoa = false;
            ings.forEach(i => { if (i.includes("Milk")) hasMilk = true; if (i.includes("Cocoa")) hasCocoa = true; });
            isAnimatingAction = true; microwave.userData.isRunning = true; microwave.userData.light.intensity = 1.0; 
            playSound(100, 100, 2.0, 'square'); showMessage("Microwaving...");
            setTimeout(() => {
                microwave.userData.light.intensity = 0; microwave.userData.isRunning = false; isAnimatingAction = false;
                playSound(600, 800, 0.5, 'sine'); showMessage("Done! (Press E to retrieve)");
                if (hasMilk && hasCocoa) {
                    cup.userData.flavor = "Hot Cocoa"; cup.userData.ingredients = ["Hot Cocoa"]; 
                    cup.userData.liquidMesh.material.color.setHex(0x553311);
                } else cup.userData.flavor = "Warm " + cup.userData.flavor;
                microwave.remove(cup); cup.scale.set(1,1,1); pickUpItem(cup); 
            }, 2000);
        }

        function onMouseDown() {
            if (!document.pointerLockElement || isAnimatingAction) return;
            if (heldItem) {
                if (heldItem.userData.type === 'pot') {
                    const target = getLookingAt();
                    if (target && target.type === 'item' && target.obj.userData.type === 'cup') pourTea(heldItem, target.obj);
                    else pourTea(heldItem, null);
                } else if (heldItem.userData.type === 'cup') sipTea(heldItem);
            }
        }

        function pickUpItem(obj) {
            heldItem = obj; const index = interactables.indexOf(obj);
            if (index > -1) interactables.splice(index, 1);
            camera.add(obj); obj.position.set(0.4, -0.3, -0.6); obj.rotation.set(0, -0.5, 0);
            showMessage(`Picked up ${obj.userData.name || obj.userData.type}`);
        }

        function dropItem(point) {
            if (!heldItem) return;
            camera.remove(heldItem); scene.add(heldItem); heldItem.position.copy(point); heldItem.rotation.set(0, Math.random() * Math.PI, 0);
            interactables.push(heldItem); heldItem = null;
        }

        function emptyCup(cup) {
            if(cup.userData.isEmpty) { showMessage("It's empty."); return; }
            playSound(300, 100, 0.3, 'noise');
            cup.userData.isEmpty = true; cup.userData.ingredients = []; cup.userData.flavor = "Empty";
            cup.userData.liquidGroup.visible = false; cup.userData.liquidGroup.scale.y = 0;
            showMessage("Cup emptied.");
        }

        function mixIngredient(cup, ingredient) {
            if (!cup.userData.liquidGroup.visible) { showMessage("Pour hot water first!"); return; }
            
            // REPAIR: Limit Logic
            if (cup.userData.ingredients.length >= 7) { showMessage("Cup is too full!"); return; }
            const ingName = ingredient.userData.name;
            
            // REPAIR: Check Whole Fruit
            if (ingName.includes("Whole")) { showMessage("Needs slicing first!"); return; }

            // REPAIR: Max 3 of same type
            const typeCount = cup.userData.ingredients.filter(i => i === ingName).length;
            if (typeCount >= 3) { showMessage(`Too much ${ingName}!`); return; }

            isAnimatingAction = true;
            const origRotX = ingredient.rotation.x;
            tweenProperty(ingredient.rotation, 'x', origRotX + 1.0, 400, () => {
                tweenProperty(ingredient.rotation, 'x', origRotX, 400, () => { isAnimatingAction = false; });
            });
            playSound(600, 800, 0.5, 'square');
            
            const isBase = ["Earl Grey", "Coffee", "Matcha"].includes(ingName);
            if (isBase) {
                 tweenColor(cup.userData.liquidMesh.material, ingredient.userData.color, 1000);
                 cup.userData.liquidMesh.material.transparent = false; cup.userData.liquidMesh.material.opacity = 1.0;
            } else {
                const c1 = cup.userData.liquidMesh.material.color; const c2 = new THREE.Color(ingredient.userData.color);
                const newColor = c1.lerp(c2, 0.2).getHex();
                tweenColor(cup.userData.liquidMesh.material, newColor, 1000);
            }
            cup.userData.ingredients.push(ingName); showMessage(`Added ${ingName}.`);
        }

        function pourTea(pot, cup) {
            isAnimatingAction = true; playSound(300, 200, 2.5, 'triangle');
            const origRotX = pot.rotation.x; tweenProperty(pot.rotation, 'x', origRotX + 0.8, 500);
            pot.userData.stream.visible = true;
            if (cup && cup.userData.isEmpty) {
                cup.userData.isEmpty = false; cup.userData.liquidGroup.visible = true;
                cup.userData.liquidMesh.material.color.setHex(0x88ccff); cup.userData.liquidMesh.material.transparent = true; cup.userData.liquidMesh.material.opacity = 0.6;
                cup.userData.ingredients = ["Hot Water"];
                tweenProperty(cup.userData.liquidGroup.scale, 'y', 1, 2500); showMessage("Pouring hot water...");
            } else if (cup) showMessage("Already full.");
            else showMessage("Spilling water!");
            setTimeout(() => {
                tweenProperty(pot.rotation, 'x', origRotX, 500, () => { isAnimatingAction = false; });
                pot.userData.stream.visible = false;
            }, 2500);
        }

        function sipTea(cup) {
            if (!cup.userData.isEmpty) {
                isAnimatingAction = true;
                const startPos = { x: 0.4, y: -0.3, z: -0.6 }; const endPos = { x: 0, y: -0.2, z: -0.35 }; const startRotX = cup.rotation.x;
                tweenProperty(cup.position, 'x', endPos.x, 500); tweenProperty(cup.position, 'y', endPos.y, 500);
                tweenProperty(cup.position, 'z', endPos.z, 500, () => {
                    tweenProperty(cup.rotation, 'x', startRotX + 1.2, 500, () => {
                        playSound(400, 500, 0.5); checkRecipe(cup.userData.ingredients);
                        tweenProperty(cup.userData.liquidGroup.scale, 'y', 0, 500, () => {
                            cup.userData.isEmpty = true; cup.userData.liquidGroup.visible = false; cup.userData.ingredients = [];
                            tweenProperty(cup.rotation, 'x', startRotX, 500);
                            tweenProperty(cup.position, 'x', startPos.x, 500); tweenProperty(cup.position, 'y', startPos.y, 500); tweenProperty(cup.position, 'z', startPos.z, 500, () => { isAnimatingAction = false; });
                        });
                    });
                });
            } else showMessage("Empty.");
        }
        
        // --- Engine Utils & Init ---
        function tweenProperty(o,p,t,d,c) { activeTweens.push({obj:o,prop:p,start:o[p],target:t,startTime:performance.now(),duration:d,onComplete:c}); }
        function tweenColor(m,t,d) { activeTweens.push({isColor:true,material:m,startColor:m.color.clone(),targetColor:new THREE.Color(t),startTime:performance.now(),duration:d}); }
        function updateTweens(time) {
            for(let i=activeTweens.length-1;i>=0;i--){
                const t=activeTweens[i], e=time-t.startTime, p=Math.min(e/t.duration,1), ep=1-(1-p)*(1-p);
                if(t.isColor) t.material.color.lerpColors(t.startColor,t.targetColor,ep); else t.obj[t.prop]=t.start*(1-ep)+t.target*ep;
                if(p>=1){ if(t.onComplete)t.onComplete(); activeTweens.splice(i,1); }
            }
        }
        function showMessage(t){ messageLog.innerText=t; messageLog.style.opacity=1; clearTimeout(messageLog.timeout); messageLog.timeout=setTimeout(()=>{messageLog.style.opacity=0;},3000); }
        function playSound(f1,f2,d,t='sine'){ if(!audioCtx)return; const o=audioCtx.createOscillator(),g=audioCtx.createGain(); o.type=t; o.frequency.setValueAtTime(f1,audioCtx.currentTime); o.frequency.linearRampToValueAtTime(f2,audioCtx.currentTime+d); g.gain.setValueAtTime(0.1,audioCtx.currentTime); g.gain.linearRampToValueAtTime(0,audioCtx.currentTime+d); o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+d); }
        function onWindowResize(){ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); }
        function checkCollisions(n){ const b=new THREE.Box3(),s=0.4; b.min.set(n.x-s,0,n.z-s); b.max.set(n.x+s,3,n.z+s); for(let o of collidableObjects)if(b.intersectsBox(o.box))return true; return false; }

        function animate(){
            requestAnimationFrame(animate);
            const time=performance.now(), delta=(time-prevTime)/1000; prevTime=time;
            updateTweens(time);
            
            updateRadio(time);
            updateSteam(delta);

            if(document.pointerLockElement===document.body){
                // ... physics logic ...
                velocity.y -= GRAVITY*delta;
                const spd = isSprinting?SPRINT_SPEED:WALK_SPEED;
                velocity.x -= velocity.x*10.0*delta; velocity.z -= velocity.z*10.0*delta;
                direction.z = Number(moveForward)-Number(moveBackward); direction.x = Number(moveLeft)-Number(moveRight); direction.normalize();
                if(moveForward||moveBackward) velocity.z -= direction.z*spd*8.0*delta; if(moveLeft||moveRight) velocity.x -= direction.x*spd*8.0*delta;
                const f=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); f.y=0; f.normalize();
                const r=new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); r.y=0; r.normalize();
                const mv=new THREE.Vector3(); mv.addScaledVector(f,-velocity.z*delta); mv.addScaledVector(r,velocity.x*delta);
                let np=camera.position.clone(); np.x+=mv.x; if(!checkCollisions(np)) camera.position.x+=mv.x;
                np=camera.position.clone(); np.z+=mv.z; if(!checkCollisions(np)) camera.position.z+=mv.z;
                camera.position.y+=velocity.y*delta;
                
                const targetHeight = isCrouching ? CROUCH_HEIGHT : PLAYER_HEIGHT;
                if(camera.position.y < targetHeight){ velocity.y=0; camera.position.y = targetHeight; canJump=true; }
            }
            // ... interaction raycast logic ...
            const t=getLookingAt();
            if(heldItem){
                interactionPrompt.style.opacity=1;
                if(t&&t.type==='surface') interactionPrompt.innerText=`[E] Place ${heldItem.userData.type}`;
                else if(t&&t.type==='item'){
                    const h=heldItem.userData.type, tt=t.obj.userData.type;
                    if(h==='ingredient'&&tt==='cup') interactionPrompt.innerText=`[E] Mix`;
                    else if(h==='cup'&&tt==='slop_bucket') interactionPrompt.innerText=`[E] Empty Cup`;
                    else if(h==='cup'&&tt==='microwave') interactionPrompt.innerText=`[E] Put in Microwave`;
                    else if(tt==='chopping_board') interactionPrompt.innerText=`[E] Place on Board`; // FEATURE Prompt
                    else interactionPrompt.innerText=`Holding ${h}`;
                } else if(heldItem.userData.type==='cup') interactionPrompt.innerText=`[Click] Sip`;
                else if(heldItem.userData.type==='pot') interactionPrompt.innerText=`[Click] Pour`;
                else interactionPrompt.innerText=`Holding ${heldItem.userData.type}`;
            } else {
                if(t&&t.type==='item'){ 
                    if(t.obj.userData.isStatic) {
                        if(t.obj.userData.type === 'microwave') interactionPrompt.innerText = `[E] Microwave`;
                        else if (t.obj.userData.type === 'radio') interactionPrompt.innerText = `[E] Radio`;
                        // FEATURE Prompt
                        else if (t.obj.userData.type === 'chopping_board') {
                            if(t.obj.userData.storedItem) {
                                if(t.obj.userData.storedItem.userData.name.includes("Whole")) interactionPrompt.innerText = `[E] Slice`;
                                else interactionPrompt.innerText = `[E] Pick up ${t.obj.userData.storedItem.userData.name}`;
                            } else interactionPrompt.innerText = `Chopping Board`;
                        }
                        else interactionPrompt.innerText = `${t.obj.userData.name}`;
                    }
                    else interactionPrompt.innerText=`[E] Pick up ${t.obj.userData.name||t.obj.userData.type}`; 
                    interactionPrompt.style.opacity=1; 
                }
                else interactionPrompt.style.opacity=0;
            }
            renderer.render(scene, camera);
        }
        camera.position.set(0,PLAYER_HEIGHT,10);
    </script>
</body>
</html>
